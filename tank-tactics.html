<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tank Tactics</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;600;700&family=Orbitron:wght@700;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --military-dark: #1a2a1a;
            --military-green: #2d4a2d;
            --military-olive: #4a6b3a;
            --ui-gold: #d4af37;
            --enemy-red: #c42c2c;
            --ally-blue: #2c5c9c;
            --neutral-gray: #7a7a7a;
            --grid-line: rgba(255, 255, 255, 0.1);
        }

        body {
            font-family: 'Rajdhani', sans-serif;
            background: linear-gradient(135deg, var(--military-dark) 0%, #0d1a0d 100%);
            color: #e0e0e0;
            overflow: hidden;
            height: 100vh;
        }

        #gameContainer {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #topBar {
            background: linear-gradient(180deg, rgba(26, 42, 26, 0.95) 0%, rgba(26, 42, 26, 0.85) 100%);
            border-bottom: 2px solid var(--ui-gold);
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        #gameTitle {
            font-family: 'Orbitron', sans-serif;
            font-size: 32px;
            font-weight: 900;
            color: var(--ui-gold);
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.5), 0 2px 4px rgba(0, 0, 0, 0.8);
            letter-spacing: 2px;
        }

        #stats {
            display: flex;
            gap: 30px;
            align-items: center;
        }

        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .stat-label {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #888;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--ui-gold);
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        #gameArea {
            flex: 1;
            display: flex;
            position: relative;
            overflow: hidden;
        }

        #canvas {
            flex: 1;
            display: block;
            cursor: crosshair;
            image-rendering: pixelated;
        }

        #sidebar {
            width: 300px;
            background: linear-gradient(180deg, rgba(26, 42, 26, 0.95) 0%, rgba(13, 26, 13, 0.95) 100%);
            border-left: 2px solid var(--ui-gold);
            padding: 20px;
            overflow-y: auto;
            box-shadow: -4px 0 20px rgba(0, 0, 0, 0.5);
        }

        .sidebar-section {
            margin-bottom: 30px;
        }

        .section-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            font-weight: 700;
            color: var(--ui-gold);
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 1px solid var(--ui-gold);
            padding-bottom: 8px;
        }

        .unit-button {
            width: 100%;
            background: linear-gradient(135deg, var(--military-green) 0%, var(--military-olive) 100%);
            border: 2px solid var(--ui-gold);
            color: white;
            padding: 12px;
            margin-bottom: 10px;
            cursor: pointer;
            font-family: 'Rajdhani', sans-serif;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .unit-button:hover {
            transform: translateX(5px);
            box-shadow: 0 4px 15px rgba(212, 175, 55, 0.3);
        }

        .unit-button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }

        .unit-button-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            margin-top: 5px;
            color: #ccc;
        }

        .unit-cost {
            color: var(--ui-gold);
            font-weight: 700;
        }

        #messageBox {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(26, 42, 26, 0.98) 0%, rgba(13, 26, 13, 0.98) 100%);
            border: 3px solid var(--ui-gold);
            padding: 40px 60px;
            text-align: center;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8);
            display: none;
            z-index: 1000;
            min-width: 400px;
        }

        #messageBox.show {
            display: block;
            animation: slideIn 0.5s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translate(-50%, -60%);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }

        #messageText {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 20px;
            color: var(--ui-gold);
        }

        .action-button {
            background: linear-gradient(135deg, var(--ally-blue) 0%, #1a4a7c 100%);
            border: 2px solid var(--ui-gold);
            color: white;
            padding: 12px 30px;
            margin: 5px;
            cursor: pointer;
            font-family: 'Rajdhani', sans-serif;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .action-button:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(212, 175, 55, 0.4);
        }

        #levelSelect {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .level-button {
            background: linear-gradient(135deg, var(--military-green) 0%, var(--military-olive) 100%);
            border: 2px solid var(--ui-gold);
            color: white;
            padding: 20px;
            cursor: pointer;
            font-family: 'Rajdhani', sans-serif;
            font-size: 18px;
            font-weight: 700;
            transition: all 0.3s ease;
            text-align: center;
        }

        .level-button:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(212, 175, 55, 0.3);
        }

        .info-text {
            font-size: 14px;
            line-height: 1.6;
            color: #ccc;
        }

        #minimap {
            width: 100%;
            height: 200px;
            border: 2px solid var(--ui-gold);
            margin-top: 20px;
            background: rgba(0, 0, 0, 0.5);
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--ui-gold);
            border-radius: 4px;
        }

        .capture-bar-container {
            position: absolute;
            width: 40px;
            height: 6px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #fff;
            margin-top: 2px;
        }

        .capture-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--ally-blue), #4a8cdc);
            transition: width 0.1s linear;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="topBar">
            <div id="gameTitle">TANK TACTICS</div>
            <div id="stats">
                <div class="stat">
                    <div class="stat-label">Denaro</div>
                    <div class="stat-value" id="moneyDisplay">$1000</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Livello</div>
                    <div class="stat-value" id="levelDisplay">1</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Nemici</div>
                    <div class="stat-value" id="enemyDisplay">0</div>
                </div>
            </div>
        </div>
        
        <div id="gameArea">
            <canvas id="canvas"></canvas>
            
            <div id="sidebar">
                <div class="sidebar-section">
                    <div class="section-title">Unit√† Disponibili</div>
                    <div id="unitButtons"></div>
                </div>
                
                <div class="sidebar-section">
                    <div class="section-title">Informazioni</div>
                    <div class="info-text" id="infoText">
                        Seleziona un'unit√† per iniziare. Conquista la base nemica o elimina tutte le truppe nemiche per vincere!
                    </div>
                </div>
                
                <div class="sidebar-section">
                    <div class="section-title">Controlli</div>
                    <div class="info-text">
                        ‚Ä¢ Click sinistro: Spara<br>
                        ‚Ä¢ WASD o Frecce: Muovi<br>
                        ‚Ä¢ Stai sopra edifici per conquistarli<br>
                        ‚Ä¢ Gli edifici generano denaro
                    </div>
                </div>
                
                <canvas id="minimap"></canvas>
            </div>
        </div>
        
        <div id="messageBox">
            <div id="messageText"></div>
            <div id="messageButtons"></div>
        </div>
    </div>

    <script>
        // ==================== CONFIGURAZIONE GIOCO ====================
        
        const GRID_SIZE = 40;
        const TILE_SIZE = 40;
        
        // Definizione tipi di unit√†
        const UNIT_TYPES = {
            soldier: {
                name: 'Soldato',
                cost: 100,
                speed: 2,
                health: 50,
                maxHealth: 50,
                damage: 10,
                captureSpeed: 1,
                fireRate: 500,
                bulletSpeed: 5,
                color: '#4a8cdc'
            },
            jeep: {
                name: 'Jeep',
                cost: 200,
                speed: 4,
                health: 80,
                maxHealth: 80,
                damage: 15,
                captureSpeed: 0.7,
                fireRate: 400,
                bulletSpeed: 6,
                color: '#6ab04c'
            },
            tank: {
                name: 'Tank',
                cost: 500,
                speed: 1.5,
                health: 200,
                maxHealth: 200,
                damage: 40,
                captureSpeed: 0.5,
                fireRate: 800,
                bulletSpeed: 7,
                color: '#e67e22'
            },
            artillery: {
                name: 'Artiglieria',
                cost: 400,
                speed: 1,
                health: 100,
                maxHealth: 100,
                damage: 60,
                captureSpeed: 0.3,
                fireRate: 1200,
                bulletSpeed: 4,
                color: '#9b59b6'
            },
            helicopter: {
                name: 'Elicottero',
                cost: 800,
                speed: 5,
                health: 120,
                maxHealth: 120,
                damage: 30,
                captureSpeed: 0,
                fireRate: 300,
                bulletSpeed: 8,
                color: '#f39c12'
            }
        };

        // Definizione tipi di edifici
        const BUILDING_TYPES = {
            base: {
                name: 'Base',
                incomePerSecond: 0,
                captureTime: 5000,
                color: '#c42c2c',
                size: 3
            },
            house: {
                name: 'Casa',
                incomePerSecond: 5,
                captureTime: 3000,
                color: '#7a7a7a',
                size: 2
            },
            airport: {
                name: 'Aeroporto',
                incomePerSecond: 0,
                captureTime: 4000,
                color: '#3498db',
                size: 3,
                powerUpInterval: 15000
            },
            barracks: {
                name: 'Caserma',
                incomePerSecond: 0,
                captureTime: 4000,
                color: '#27ae60',
                size: 2,
                spawnInterval: 10000
            },
            hospital: {
                name: 'Ospedale',
                incomePerSecond: 0,
                captureTime: 3500,
                color: '#e74c3c',
                size: 2
            }
        };

        // Definizione livelli
        const LEVELS = [
            {
                id: 1,
                name: 'Livello 1 - Introduzione',
                gridWidth: 30,
                gridHeight: 20,
                startMoney: 1000,
                fogOfWar: false,
                playerStart: { x: 2, y: 10 },
                buildings: [
                    { type: 'base', x: 2, y: 10, owner: 'player' },
                    { type: 'house', x: 10, y: 8, owner: 'neutral' },
                    { type: 'house', x: 10, y: 12, owner: 'neutral' },
                    { type: 'base', x: 27, y: 10, owner: 'enemy' }
                ],
                enemies: [
                    { type: 'soldier', x: 25, y: 10, maxSpawns: 3 },
                    { type: 'jeep', x: 24, y: 8, maxSpawns: 2 }
                ],
                obstacles: []
            },
            {
                id: 2,
                name: 'Livello 2 - Difesa',
                gridWidth: 35,
                gridHeight: 25,
                startMoney: 800,
                fogOfWar: false,
                playerStart: { x: 3, y: 12 },
                buildings: [
                    { type: 'base', x: 3, y: 12, owner: 'player' },
                    { type: 'barracks', x: 8, y: 12, owner: 'neutral' },
                    { type: 'house', x: 15, y: 8, owner: 'neutral' },
                    { type: 'house', x: 15, y: 16, owner: 'neutral' },
                    { type: 'hospital', x: 20, y: 12, owner: 'neutral' },
                    { type: 'base', x: 31, y: 12, owner: 'enemy' }
                ],
                enemies: [
                    { type: 'soldier', x: 29, y: 10, maxSpawns: 4 },
                    { type: 'soldier', x: 29, y: 14, maxSpawns: 4 },
                    { type: 'jeep', x: 28, y: 12, maxSpawns: 3 },
                    { type: 'tank', x: 30, y: 12, maxSpawns: 1 }
                ],
                obstacles: [
                    { x: 12, y: 5, width: 2, height: 5 },
                    { x: 12, y: 15, width: 2, height: 5 }
                ]
            },
            {
                id: 3,
                name: 'Livello 3 - Nebbia di Guerra',
                gridWidth: 40,
                gridHeight: 30,
                startMoney: 1200,
                fogOfWar: true,
                playerStart: { x: 3, y: 15 },
                buildings: [
                    { type: 'base', x: 3, y: 15, owner: 'player' },
                    { type: 'house', x: 10, y: 10, owner: 'neutral' },
                    { type: 'house', x: 10, y: 20, owner: 'neutral' },
                    { type: 'airport', x: 20, y: 15, owner: 'neutral' },
                    { type: 'barracks', x: 28, y: 10, owner: 'enemy' },
                    { type: 'hospital', x: 28, y: 20, owner: 'enemy' },
                    { type: 'base', x: 36, y: 15, owner: 'enemy' }
                ],
                enemies: [
                    { type: 'soldier', x: 34, y: 13, maxSpawns: 5 },
                    { type: 'soldier', x: 34, y: 17, maxSpawns: 5 },
                    { type: 'jeep', x: 32, y: 15, maxSpawns: 3 },
                    { type: 'tank', x: 35, y: 15, maxSpawns: 2 },
                    { type: 'artillery', x: 30, y: 15, maxSpawns: 2 }
                ],
                obstacles: [
                    { x: 15, y: 8, width: 3, height: 3 },
                    { x: 15, y: 19, width: 3, height: 3 },
                    { x: 25, y: 5, width: 2, height: 8 },
                    { x: 25, y: 17, width: 2, height: 8 }
                ]
            }
        ];

        // ==================== STATO DEL GIOCO ====================
        
        let gameState = {
            currentLevel: null,
            money: 1000,
            player: null,
            enemies: [],
            bullets: [],
            buildings: [],
            obstacles: [],
            particles: [],
            powerUps: [],
            keys: {},
            mousePos: { x: 0, y: 0 },
            camera: { x: 0, y: 0 },
            gameRunning: false,
            spawnPoint: null,
            visibilityMap: [],
            lastIncomeTime: Date.now(),
            enemySpawnCounts: {}
        };

        // ==================== CANVAS E RENDERING ====================
        
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const minimap = document.getElementById('minimap');
        const minimapCtx = minimap.getContext('2d');

        function resizeCanvas() {
            const container = document.getElementById('gameArea');
            canvas.width = container.clientWidth - 300;
            canvas.height = container.clientHeight;
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // ==================== CLASSI ====================
        
        class Unit {
            constructor(type, x, y, owner = 'player') {
                const config = UNIT_TYPES[type];
                Object.assign(this, config);
                this.type = type;
                this.x = x;
                this.y = y;
                this.owner = owner;
                this.lastFired = 0;
                this.target = null;
                this.capturingBuilding = null;
                this.captureProgress = 0;
            }

            update(deltaTime) {
                if (this.owner === 'player') {
                    this.updatePlayer(deltaTime);
                } else {
                    this.updateEnemy(deltaTime);
                }

                // Check building capture
                this.checkBuildingCapture(deltaTime);
            }

            updatePlayer(deltaTime) {
                let dx = 0, dy = 0;
                if (gameState.keys['w'] || gameState.keys['ArrowUp']) dy -= 1;
                if (gameState.keys['s'] || gameState.keys['ArrowDown']) dy += 1;
                if (gameState.keys['a'] || gameState.keys['ArrowLeft']) dx -= 1;
                if (gameState.keys['d'] || gameState.keys['ArrowRight']) dx += 1;

                if (dx !== 0 || dy !== 0) {
                    const len = Math.sqrt(dx * dx + dy * dy);
                    dx /= len;
                    dy /= len;
                    
                    const newX = this.x + dx * this.speed;
                    const newY = this.y + dy * this.speed;
                    
                    if (this.canMoveTo(newX, newY)) {
                        this.x = newX;
                        this.y = newY;
                    }
                }
            }

            updateEnemy(deltaTime) {
                if (!gameState.player) return;

                const dx = gameState.player.x - this.x;
                const dy = gameState.player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > 300) {
                    const ndx = dx / dist;
                    const ndy = dy / dist;
                    const newX = this.x + ndx * this.speed;
                    const newY = this.y + ndy * this.speed;
                    
                    if (this.canMoveTo(newX, newY)) {
                        this.x = newX;
                        this.y = newY;
                    }
                }

                if (dist < 400 && Date.now() - this.lastFired > this.fireRate) {
                    this.fire(gameState.player.x, gameState.player.y);
                }
            }

            canMoveTo(x, y) {
                const level = gameState.currentLevel;
                if (x < 0 || y < 0 || x >= level.gridWidth * TILE_SIZE || y >= level.gridHeight * TILE_SIZE) {
                    return false;
                }

                for (const obstacle of gameState.obstacles) {
                    if (x >= obstacle.x && x < obstacle.x + obstacle.width * TILE_SIZE &&
                        y >= obstacle.y && y < obstacle.y + obstacle.height * TILE_SIZE) {
                        return false;
                    }
                }

                return true;
            }

            fire(targetX, targetY) {
                const dx = targetX - this.x;
                const dy = targetY - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                gameState.bullets.push({
                    x: this.x,
                    y: this.y,
                    vx: (dx / dist) * this.bulletSpeed,
                    vy: (dy / dist) * this.bulletSpeed,
                    damage: this.damage,
                    owner: this.owner
                });

                this.lastFired = Date.now();
                
                // Particle effect
                for (let i = 0; i < 5; i++) {
                    gameState.particles.push({
                        x: this.x,
                        y: this.y,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        life: 20,
                        color: '#ffaa00'
                    });
                }
            }

            checkBuildingCapture(deltaTime) {
                let isCapturing = false;

                for (const building of gameState.buildings) {
                    const bx = building.x * TILE_SIZE + (building.size * TILE_SIZE) / 2;
                    const by = building.y * TILE_SIZE + (building.size * TILE_SIZE) / 2;
                    const dist = Math.sqrt((this.x - bx) ** 2 + (this.y - by) ** 2);

                    if (dist < building.size * TILE_SIZE / 2 && building.owner !== this.owner) {
                        if (this.capturingBuilding !== building) {
                            this.capturingBuilding = building;
                            this.captureProgress = 0;
                        }

                        this.captureProgress += (deltaTime / building.captureTime) * this.captureSpeed;

                        if (this.captureProgress >= 1) {
                            building.owner = this.owner;
                            this.captureProgress = 0;
                            this.capturingBuilding = null;
                            
                            if (this.owner === 'player' && building.type === 'hospital') {
                                gameState.spawnPoint = { x: building.x * TILE_SIZE, y: building.y * TILE_SIZE };
                            }
                            
                            showMessage(`${building.name} conquistato!`, 1500);
                        }

                        isCapturing = true;
                        break;
                    }
                }

                if (!isCapturing) {
                    this.capturingBuilding = null;
                    this.captureProgress = 0;
                }
            }

            takeDamage(damage) {
                this.health -= damage;
                
                for (let i = 0; i < 10; i++) {
                    gameState.particles.push({
                        x: this.x,
                        y: this.y,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4,
                        life: 30,
                        color: '#ff0000'
                    });
                }

                return this.health <= 0;
            }

            draw() {
                const screenX = this.x - gameState.camera.x;
                const screenY = this.y - gameState.camera.y;

                // Unit body
                ctx.fillStyle = this.color;
                ctx.strokeStyle = this.owner === 'player' ? '#fff' : '#000';
                ctx.lineWidth = 2;

                if (this.type === 'helicopter') {
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, 12, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                } else if (this.type === 'tank') {
                    ctx.fillRect(screenX - 12, screenY - 12, 24, 24);
                    ctx.strokeRect(screenX - 12, screenY - 12, 24, 24);
                } else {
                    ctx.fillRect(screenX - 10, screenY - 10, 20, 20);
                    ctx.strokeRect(screenX - 10, screenY - 10, 20, 20);
                }

                // Health bar
                const barWidth = 30;
                const barHeight = 4;
                const healthPercent = this.health / this.maxHealth;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(screenX - barWidth/2, screenY - 20, barWidth, barHeight);
                
                ctx.fillStyle = healthPercent > 0.5 ? '#2ecc71' : (healthPercent > 0.25 ? '#f39c12' : '#e74c3c');
                ctx.fillRect(screenX - barWidth/2, screenY - 20, barWidth * healthPercent, barHeight);

                // Capture progress
                if (this.capturingBuilding && this.owner === 'player') {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(screenX - 20, screenY + 20, 40, 6);
                    ctx.fillStyle = '#4a8cdc';
                    ctx.fillRect(screenX - 20, screenY + 20, 40 * this.captureProgress, 6);
                }
            }
        }

        // ==================== FUNZIONI DI GIOCO ====================
        
        function startLevel(levelId) {
            const level = LEVELS.find(l => l.id === levelId);
            if (!level) return;

            gameState.currentLevel = level;
            gameState.money = level.startMoney;
            gameState.enemies = [];
            gameState.bullets = [];
            gameState.buildings = [];
            gameState.obstacles = [];
            gameState.particles = [];
            gameState.powerUps = [];
            gameState.player = null;
            gameState.enemySpawnCounts = {};

            // Create buildings
            for (const bData of level.buildings) {
                gameState.buildings.push({
                    ...BUILDING_TYPES[bData.type],
                    type: bData.type,
                    x: bData.x,
                    y: bData.y,
                    owner: bData.owner,
                    lastPowerUp: 0,
                    lastSpawn: 0
                });
            }

            // Create obstacles
            for (const obs of level.obstacles) {
                gameState.obstacles.push({
                    x: obs.x * TILE_SIZE,
                    y: obs.y * TILE_SIZE,
                    width: obs.width,
                    height: obs.height
                });
            }

            // Initialize enemy spawn counts
            for (let i = 0; i < level.enemies.length; i++) {
                gameState.enemySpawnCounts[i] = 0;
            }

            // Initialize spawn point
            const playerBase = gameState.buildings.find(b => b.owner === 'player' && b.type === 'base');
            if (playerBase) {
                gameState.spawnPoint = { 
                    x: playerBase.x * TILE_SIZE + TILE_SIZE, 
                    y: playerBase.y * TILE_SIZE + TILE_SIZE 
                };
            }

            // Initialize fog of war
            if (level.fogOfWar) {
                gameState.visibilityMap = Array(level.gridHeight).fill(0).map(() => Array(level.gridWidth).fill(0));
            }

            document.getElementById('levelDisplay').textContent = levelId;
            hideMessage();
            showUnitSelection();
        }

        function showUnitSelection() {
            const container = document.getElementById('unitButtons');
            container.innerHTML = '';

            for (const [key, unit] of Object.entries(UNIT_TYPES)) {
                const button = document.createElement('button');
                button.className = 'unit-button';
                button.disabled = gameState.money < unit.cost;
                
                button.innerHTML = `
                    <div>${unit.name}</div>
                    <div class="unit-button-info">
                        <span>‚ù§Ô∏è ${unit.health} | ‚öîÔ∏è ${unit.damage} | üèÉ ${unit.speed}</span>
                        <span class="unit-cost">$${unit.cost}</span>
                    </div>
                `;
                
                button.onclick = () => spawnPlayerUnit(key);
                container.appendChild(button);
            }
        }

        function spawnPlayerUnit(type) {
            if (gameState.money < UNIT_TYPES[type].cost) return;

            gameState.money -= UNIT_TYPES[type].cost;
            
            const spawnX = gameState.spawnPoint.x;
            const spawnY = gameState.spawnPoint.y;
            
            gameState.player = new Unit(type, spawnX, spawnY, 'player');
            gameState.gameRunning = true;
            
            updateUI();
            hideMessage();
        }

        function spawnEnemy(enemyConfig, index) {
            if (gameState.enemySpawnCounts[index] >= enemyConfig.maxSpawns) return;

            const unit = new Unit(
                enemyConfig.type,
                enemyConfig.x * TILE_SIZE,
                enemyConfig.y * TILE_SIZE,
                'enemy'
            );
            
            gameState.enemies.push(unit);
            gameState.enemySpawnCounts[index]++;
        }

        function updateGame(deltaTime) {
            if (!gameState.gameRunning || !gameState.player) return;

            // Update player
            gameState.player.update(deltaTime);

            // Update enemies
            for (const enemy of gameState.enemies) {
                enemy.update(deltaTime);
            }

            // Update bullets
            for (let i = gameState.bullets.length - 1; i >= 0; i--) {
                const bullet = gameState.bullets[i];
                bullet.x += bullet.vx;
                bullet.y += bullet.vy;

                // Check collision with units
                const targets = bullet.owner === 'player' ? gameState.enemies : [gameState.player];
                
                for (let j = targets.length - 1; j >= 0; j--) {
                    const target = targets[j];
                    if (!target) continue;
                    
                    const dist = Math.sqrt((bullet.x - target.x) ** 2 + (bullet.y - target.y) ** 2);
                    
                    if (dist < 15) {
                        if (target.takeDamage(bullet.damage)) {
                            if (bullet.owner === 'player') {
                                gameState.enemies.splice(j, 1);
                            } else {
                                onPlayerDeath();
                            }
                        }
                        gameState.bullets.splice(i, 1);
                        break;
                    }
                }

                // Remove out of bounds bullets
                const level = gameState.currentLevel;
                if (bullet.x < 0 || bullet.y < 0 || 
                    bullet.x > level.gridWidth * TILE_SIZE || 
                    bullet.y > level.gridHeight * TILE_SIZE) {
                    gameState.bullets.splice(i, 1);
                }
            }

            // Update particles
            for (let i = gameState.particles.length - 1; i >= 0; i--) {
                const p = gameState.particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                if (p.life <= 0) {
                    gameState.particles.splice(i, 1);
                }
            }

            // Generate income
            const now = Date.now();
            if (now - gameState.lastIncomeTime > 1000) {
                for (const building of gameState.buildings) {
                    if (building.owner === 'player' && building.incomePerSecond > 0) {
                        gameState.money += building.incomePerSecond;
                    }
                }
                gameState.lastIncomeTime = now;
            }

            // Spawn enemies from barracks
            for (const building of gameState.buildings) {
                if (building.owner === 'enemy' && building.type === 'barracks') {
                    if (now - building.lastSpawn > building.spawnInterval) {
                        const level = gameState.currentLevel;
                        if (level.enemies.length > 0) {
                            const randomEnemy = level.enemies[Math.floor(Math.random() * level.enemies.length)];
                            const spawnX = building.x * TILE_SIZE + TILE_SIZE;
                            const spawnY = building.y * TILE_SIZE + TILE_SIZE;
                            gameState.enemies.push(new Unit(randomEnemy.type, spawnX, spawnY, 'enemy'));
                        }
                        building.lastSpawn = now;
                    }
                }
            }

            // Spawn initial enemies if needed
            const level = gameState.currentLevel;
            if (gameState.enemies.length < 3) {
                for (let i = 0; i < level.enemies.length; i++) {
                    const enemyConfig = level.enemies[i];
                    if (gameState.enemySpawnCounts[i] < enemyConfig.maxSpawns) {
                        spawnEnemy(enemyConfig, i);
                        break;
                    }
                }
            }

            // Check win condition
            checkWinCondition();

            // Update camera
            updateCamera();

            // Update fog of war
            if (level.fogOfWar) {
                updateFogOfWar();
            }

            updateUI();
        }

        function updateCamera() {
            if (!gameState.player) return;

            const targetX = gameState.player.x - canvas.width / 2;
            const targetY = gameState.player.y - canvas.height / 2;

            gameState.camera.x = targetX;
            gameState.camera.y = targetY;

            const level = gameState.currentLevel;
            gameState.camera.x = Math.max(0, Math.min(gameState.camera.x, level.gridWidth * TILE_SIZE - canvas.width));
            gameState.camera.y = Math.max(0, Math.min(gameState.camera.y, level.gridHeight * TILE_SIZE - canvas.height));
        }

        function updateFogOfWar() {
            const level = gameState.currentLevel;
            const visionRange = 8;

            // Fade existing visibility
            for (let y = 0; y < level.gridHeight; y++) {
                for (let x = 0; x < level.gridWidth; x++) {
                    gameState.visibilityMap[y][x] = Math.max(0, gameState.visibilityMap[y][x] - 0.02);
                }
            }

            // Add visibility around player
            if (gameState.player) {
                const px = Math.floor(gameState.player.x / TILE_SIZE);
                const py = Math.floor(gameState.player.y / TILE_SIZE);

                for (let dy = -visionRange; dy <= visionRange; dy++) {
                    for (let dx = -visionRange; dx <= visionRange; dx++) {
                        const x = px + dx;
                        const y = py + dy;
                        if (x >= 0 && x < level.gridWidth && y >= 0 && y < level.gridHeight) {
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist <= visionRange) {
                                gameState.visibilityMap[y][x] = Math.min(1, gameState.visibilityMap[y][x] + 0.2);
                            }
                        }
                    }
                }
            }
        }

        function checkWinCondition() {
            const level = gameState.currentLevel;
            
            // Check if all enemy bases are captured
            const enemyBases = gameState.buildings.filter(b => b.type === 'base' && b.owner === 'enemy');
            
            // Check if all enemies are eliminated and no more can spawn
            let allEnemiesDefeated = gameState.enemies.length === 0;
            for (let i = 0; i < level.enemies.length; i++) {
                if (gameState.enemySpawnCounts[i] < level.enemies[i].maxSpawns) {
                    allEnemiesDefeated = false;
                    break;
                }
            }

            if (enemyBases.length === 0 || allEnemiesDefeated) {
                gameState.gameRunning = false;
                showMessage('VITTORIA!', 0, [
                    { text: 'Prossimo Livello', action: () => {
                        const nextLevel = level.id + 1;
                        if (LEVELS.find(l => l.id === nextLevel)) {
                            startLevel(nextLevel);
                        } else {
                            showLevelSelect();
                        }
                    }},
                    { text: 'Menu Livelli', action: showLevelSelect }
                ]);
            }
        }

        function onPlayerDeath() {
            gameState.player = null;
            gameState.gameRunning = false;

            if (gameState.money >= 100) {
                showMessage('Sei stato eliminato!', 0, [
                    { text: 'Respawn', action: () => showUnitSelection() },
                    { text: 'Menu Livelli', action: showLevelSelect }
                ]);
            } else {
                showMessage('GAME OVER - Denaro Insufficiente', 0, [
                    { text: 'Riprova Livello', action: () => startLevel(gameState.currentLevel.id) },
                    { text: 'Menu Livelli', action: showLevelSelect }
                ]);
            }
        }

        function drawGame() {
            ctx.fillStyle = '#1a2a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const level = gameState.currentLevel;
            if (!level) return;

            // Draw grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            
            const startX = Math.floor(gameState.camera.x / TILE_SIZE);
            const startY = Math.floor(gameState.camera.y / TILE_SIZE);
            const endX = Math.ceil((gameState.camera.x + canvas.width) / TILE_SIZE);
            const endY = Math.ceil((gameState.camera.y + canvas.height) / TILE_SIZE);

            for (let x = startX; x <= endX; x++) {
                const screenX = x * TILE_SIZE - gameState.camera.x;
                ctx.beginPath();
                ctx.moveTo(screenX, 0);
                ctx.lineTo(screenX, canvas.height);
                ctx.stroke();
            }

            for (let y = startY; y <= endY; y++) {
                const screenY = y * TILE_SIZE - gameState.camera.y;
                ctx.beginPath();
                ctx.moveTo(0, screenY);
                ctx.lineTo(canvas.width, screenY);
                ctx.stroke();
            }

            // Draw obstacles
            ctx.fillStyle = '#333';
            for (const obs of gameState.obstacles) {
                const screenX = obs.x - gameState.camera.x;
                const screenY = obs.y - gameState.camera.y;
                ctx.fillRect(screenX, screenY, obs.width * TILE_SIZE, obs.height * TILE_SIZE);
            }

            // Draw buildings
            for (const building of gameState.buildings) {
                const screenX = building.x * TILE_SIZE - gameState.camera.x;
                const screenY = building.y * TILE_SIZE - gameState.camera.y;
                
                let color = building.color;
                if (building.owner === 'player') color = '#2c5c9c';
                else if (building.owner === 'neutral') color = '#7a7a7a';

                ctx.fillStyle = color;
                ctx.fillRect(screenX, screenY, building.size * TILE_SIZE, building.size * TILE_SIZE);
                
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(screenX, screenY, building.size * TILE_SIZE, building.size * TILE_SIZE);

                // Building label
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 12px Rajdhani';
                ctx.textAlign = 'center';
                ctx.fillText(building.name, screenX + building.size * TILE_SIZE / 2, screenY - 5);
            }

            // Draw particles
            for (const p of gameState.particles) {
                const screenX = p.x - gameState.camera.x;
                const screenY = p.y - gameState.camera.y;
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life / 30;
                ctx.fillRect(screenX - 2, screenY - 2, 4, 4);
                ctx.globalAlpha = 1;
            }

            // Draw bullets
            ctx.fillStyle = '#ffff00';
            for (const bullet of gameState.bullets) {
                const screenX = bullet.x - gameState.camera.x;
                const screenY = bullet.y - gameState.camera.y;
                ctx.beginPath();
                ctx.arc(screenX, screenY, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw enemies
            for (const enemy of gameState.enemies) {
                enemy.draw();
            }

            // Draw player
            if (gameState.player) {
                gameState.player.draw();
            }

            // Draw fog of war
            if (level.fogOfWar) {
                for (let y = 0; y < level.gridHeight; y++) {
                    for (let x = 0; x < level.gridWidth; x++) {
                        const visibility = gameState.visibilityMap[y][x];
                        if (visibility < 1) {
                            const screenX = x * TILE_SIZE - gameState.camera.x;
                            const screenY = y * TILE_SIZE - gameState.camera.y;
                            ctx.fillStyle = `rgba(0, 0, 0, ${1 - visibility})`;
                            ctx.fillRect(screenX, screenY, TILE_SIZE, TILE_SIZE);
                        }
                    }
                }
            }

            // Draw minimap
            drawMinimap();
        }

        function drawMinimap() {
            const level = gameState.currentLevel;
            if (!level) return;

            minimapCtx.fillStyle = '#000';
            minimapCtx.fillRect(0, 0, minimap.width, minimap.height);

            const scaleX = minimap.width / level.gridWidth;
            const scaleY = minimap.height / level.gridHeight;

            // Draw buildings
            for (const building of gameState.buildings) {
                let color = '#7a7a7a';
                if (building.owner === 'player') color = '#2c5c9c';
                else if (building.owner === 'enemy') color = '#c42c2c';

                minimapCtx.fillStyle = color;
                minimapCtx.fillRect(
                    building.x * scaleX,
                    building.y * scaleY,
                    building.size * scaleX,
                    building.size * scaleY
                );
            }

            // Draw player
            if (gameState.player) {
                minimapCtx.fillStyle = '#4a8cdc';
                const px = (gameState.player.x / TILE_SIZE) * scaleX;
                const py = (gameState.player.y / TILE_SIZE) * scaleY;
                minimapCtx.fillRect(px - 2, py - 2, 4, 4);
            }

            // Draw enemies
            minimapCtx.fillStyle = '#c42c2c';
            for (const enemy of gameState.enemies) {
                const ex = (enemy.x / TILE_SIZE) * scaleX;
                const ey = (enemy.y / TILE_SIZE) * scaleY;
                minimapCtx.fillRect(ex - 1, ey - 1, 2, 2);
            }
        }

        function updateUI() {
            document.getElementById('moneyDisplay').textContent = `$${gameState.money}`;
            document.getElementById('enemyDisplay').textContent = gameState.enemies.length;
            showUnitSelection();
        }

        function showMessage(text, duration = 0, buttons = []) {
            const messageBox = document.getElementById('messageBox');
            const messageText = document.getElementById('messageText');
            const messageButtons = document.getElementById('messageButtons');

            messageText.textContent = text;
            messageButtons.innerHTML = '';

            for (const btn of buttons) {
                const button = document.createElement('button');
                button.className = 'action-button';
                button.textContent = btn.text;
                button.onclick = btn.action;
                messageButtons.appendChild(button);
            }

            messageBox.classList.add('show');

            if (duration > 0) {
                setTimeout(() => hideMessage(), duration);
            }
        }

        function hideMessage() {
            document.getElementById('messageBox').classList.remove('show');
        }

        function showLevelSelect() {
            gameState.gameRunning = false;
            
            const buttons = LEVELS.map(level => ({
                text: level.name,
                action: () => startLevel(level.id)
            }));

            showMessage('Seleziona un Livello', 0, buttons);
        }

        // ==================== EVENT LISTENERS ====================
        
        document.addEventListener('keydown', (e) => {
            gameState.keys[e.key] = true;
        });

        document.addEventListener('keyup', (e) => {
            gameState.keys[e.key] = false;
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            gameState.mousePos.x = e.clientX - rect.left + gameState.camera.x;
            gameState.mousePos.y = e.clientY - rect.top + gameState.camera.y;
        });

        canvas.addEventListener('click', (e) => {
            if (gameState.player && gameState.gameRunning) {
                gameState.player.fire(gameState.mousePos.x, gameState.mousePos.y);
            }
        });

        // ==================== GAME LOOP ====================
        
        let lastTime = Date.now();

        function gameLoop() {
            const now = Date.now();
            const deltaTime = now - lastTime;
            lastTime = now;

            updateGame(deltaTime);
            drawGame();

            requestAnimationFrame(gameLoop);
        }

        // ==================== START ====================
        
        showLevelSelect();
        gameLoop();
    </script>
</body>
</html>